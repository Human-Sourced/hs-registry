import { NextResponse } from 'next/server';
import { getServerSupabase } from '@/lib/supabase';

export const runtime = 'nodejs';

type Tier = 'ETHICAL_AI' | 'HUMAN_LED' | 'HUMAN_FIRST' | 'HUMAN_CRAFTED';
type Status = 'ACTIVE' | 'CONDITIONAL' | 'EXPIRED' | 'SUSPENDED' | 'REVOKED';

type IssueBody = {
  org_slug: string;           // e.g. "brightwave-creative"
  legal_name: string;         // "BrightWave Creative LLC"
  public_name: string;        // "BrightWave Creative"
  website?: string;
  contact_email?: string;

  tier: Tier;                 // required
  status?: Status;            // default ACTIVE
  issued_at?: string;         // optional ISO timestamp override
  expires_at?: string;        // optional ISO timestamp
  registry_slug?: string;     // optional pretty URL path (unique)
};

function msgOf(e: unknown): string {
  if (e && typeof e === 'object' && 'message' in e) {
    const m = (e as { message?: unknown }).message;
    return typeof m === 'string' ? m : JSON.stringify(m);
  }
  try { return String(e); } catch { return 'Unknown error'; }
}

export async function POST(req: Request) {
  // --- auth ---
  const adminKey = process.env.ADMIN_API_KEY;
  const headerKey = req.headers.get('x-admin-key') ?? '';
  if (!adminKey || headerKey !== adminKey) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // --- input ---
  let body: IssueBody;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
  }

  // minimal validation (no extra deps)
  if (!body.org_slug?.trim() || !body.legal_name?.trim() || !body.public_name?.trim() || !body.tier) {
    return NextResponse.json({ error: 'Missing required fields: org_slug, legal_name, public_name, tier' }, { status: 400 });
  }

  const supabase = getServerSupabase();

  // 1) Upsert org by slug
  const { data: org, error: orgErr } = await supabase
    .from('organizations')
    .upsert(
      {
        slug: body.org_slug.trim(),
        legal_name: body.legal_name.trim(),
        public_name: body.public_name.trim(),
        website: body.website ?? null,
        contact_email: body.contact_email ?? null,
      },
      { onConflict: 'slug' }
    )
    .select('*')
    .single();

  if (orgErr || !org) {
    return NextResponse.json({ error: orgErr?.message ?? 'Organization upsert failed' }, { status: 500 });
  }

  // 2) Insert certification (serial_id auto-generated by default)
  const insertPayload: Record<string, unknown> = {
    org_id: org.id,
    tier: body.tier,
    status: body.status ?? 'ACTIVE',
    registry_slug: body.registry_slug ?? null,
  };
  if (body.issued_at) insertPayload.issued_at = body.issued_at;
  if (body.expires_at) insertPayload.expires_at = body.expires_at;

  const { data: cert, error: certErr } = await supabase
    .from('certifications')
    .insert(insertPayload)
    .select('serial_id, issued_at, expires_at, status, tier')
    .single();

  if (certErr || !cert) {
    return NextResponse.json({ error: certErr?.message ?? 'Certification insert failed' }, { status: 500 });
  }

  // 3) Audit log (best-effort)
  const details = {
    org_slug: body.org_slug,
    registry_slug: body.registry_slug ?? null,
    requested_status: body.status ?? 'ACTIVE',
    requested_tier: body.tier,
  };
  await supabase
    .from('admin_audit_log')
    .insert({
      action: 'ISSUE_CERT',
      target_serial: cert.serial_id,
      details,
    });

  // 4) Useful URLs
  const base = process.env.NEXT_PUBLIC_BASE_URL ?? 'https://registry.human-sourced.com';
  const serial = cert.serial_id as string;
  const response = {
    serial,
    issued_at: cert.issued_at,
    expires_at: cert.expires_at,
    status: cert.status,
    tier: cert.tier,
    org: org.public_name,
    urls: {
      certificate: `${base}/certificate/${encodeURIComponent(serial)}`,
      badge_svg: `${base}/badge/${encodeURIComponent(serial)}.svg`,
      qr_png: `${base}/qr/${encodeURIComponent(serial)}.png`,
      api_verify: `${base}/api/v1/verify?serial=${encodeURIComponent(serial)}`,
    },
  };

  return NextResponse.json(response, { status: 201 });
}
